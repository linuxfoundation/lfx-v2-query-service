# lfx-v2-query-service
LFX v2 Platform Query

## Architecture Overview

The implementation follows the clean architecture principles where:
- **Domain Layer**: Contains business logic and interfaces
- **Service Layer**: Orchestrates business operations
- **Infrastructure Layer**: Implements external dependencies
- **Presentation Layer**: Handles HTTP/API concerns (generated by Goa)

## Directory Structure

```
├── internal/
│   ├── domain/
│   │   └── interfaces.go          # Domain interfaces and models
│   ├── service/
│   │   └── resource_service.go    # Business logic layer
│   └── infrastructure/
│       ├── elasticsearch/
│       │   ├── templates.go       # Elasticsearch query templates
│       │   ├── searcher.go        # Elasticsearch implementation
│       │   └── client.go          # HTTP client for Elasticsearch
│       └── mock/
│           └── searcher.go        # Mock implementation for testing
├── cmd/query_svc/
│   └── main.go                    # Dependency injection and startup
└── query_svc.go                   # Goa service implementation
```

## Key Components

### Domain Layer (`internal/domain/`)
- **ResourceSearcher Interface**: Defines the contract for resource search operations
- **Domain Models**: Pure business entities without infrastructure dependencies
- **Search Criteria**: Encapsulates search parameters
- **Search Result**: Represents search outcomes

### Service Layer (`internal/service/`)
- **ResourceService**: Contains business logic and validation
- **Validation**: Ensures business rules are enforced
- **Orchestration**: Coordinates between domain and infrastructure layers

### Infrastructure Layer (`internal/infrastructure/`)

#### Elasticsearch Implementation
- **templates.go**: Contains Elasticsearch query templates for different search scenarios
- **searcher.go**: Implements the ResourceSearcher interface using Elasticsearch
- **client.go**: HTTP client for communicating with Elasticsearch cluster

#### Mock Implementation
- **searcher.go**: In-memory implementation for testing and development

## Dependency Injection

The clean architecture is wired together in `cmd/query_svc/main.go`:

```go
// Choose implementation based on configuration
var resourceSearcher domain.ResourceSearcher

switch *searchImpl {
case "mock":
    resourceSearcher = mock.NewMockResourceSearcher()
case "elasticsearch":
    resourceSearcher, err = elasticsearch.NewElasticsearchSearcherFromConfig(esConfig)
}

// Inject into service
querySvcSvc = querysvcapi.NewQuerySvc(resourceSearcher)
```

## Benefits of This Architecture

1. **Testability**: Easy to swap implementations for testing
2. **Flexibility**: Can easily switch between different search backends
3. **Maintainability**: Clear separation of concerns
4. **Scalability**: Easy to add new search implementations
5. **Independence**: Layers don't depend on external frameworks

## Usage

### Running with Mock Implementation (Default)
```bash
go run cmd/query_svc/main.go -search-impl=mock
```

### Running with Elasticsearch
```bash
go run cmd/query_svc/main.go \
    -search-impl=elasticsearch \
    -es-url=http://localhost:9200 \
    -es-index=lfx-resources \
    -es-username=elastic \
    -es-password=changeme
```

### Available Command Line Flags

**Search Implementation:**
- `-search-impl`: Choose between "mock" or "elasticsearch" (default: "mock")

**Elasticsearch Configuration:**
- `-es-url`: Elasticsearch URL (default: "http://localhost:9200")
- `-es-username`: Elasticsearch username
- `-es-password`: Elasticsearch password
- `-es-index`: Elasticsearch index name (default: "lfx-resources")

**Server Configuration:**
- `-host`: Server host (default: "localhost")
- `-http-port`: HTTP port
- `-debug`: Enable debug logging

## API Usage

The service exposes a RESTful API through the Goa framework:

```
GET /query/resources?name=committee&type=committee&v=1
```

**Parameters:**
- `name`: Resource name or alias (supports typeahead search)
- `type`: Resource type to filter by
- `parent`: Parent resource for hierarchical queries
- `tags`: Array of tags to filter by
- `sort`: Sort order (name_asc, name_desc, updated_asc, updated_desc)
- `page_token`: Pagination token
- `v`: API version (required)

**Response:**
```json
{
  "resources": [
    {
      "type": "committee",
      "id": "123",
      "data": {
        "name": "Technical Advisory Committee",
        "description": "Main technical governance body",
        "status": "active"
      }
    }
  ],
  "page_token": "offset_50",
  "cache_control": "public, max-age=300"
}
```

## Elasticsearch Query Templates

The Elasticsearch implementation uses template-based queries located in `internal/infrastructure/elasticsearch/templates.go`:

- **Resource Search Template**: Full-featured search with filtering, sorting, and pagination
- **Typeahead Template**: Optimized for autocomplete scenarios

Templates support:
- Multi-field text search with relevance scoring
- Exact term filtering (type, parent, tags)
- Multiple sort options
- Pagination with search_after
- Highlighting for matched terms

## Testing

The clean architecture makes testing straightforward:

```go
// Use mock implementation for unit tests
searcher := mock.NewMockResourceSearcher()
searcher.AddResource(testResource)

service := service.NewResourceService(searcher)
result, err := service.QueryResources(ctx, criteria)
```

## Extending the Architecture

To add a new search implementation:

1. Create a new package in `internal/infrastructure/`
2. Implement the `domain.ResourceSearcher` interface
3. Add configuration options to `main.go`
4. Update the dependency injection switch statement

The domain and service layers remain unchanged, demonstrating the power of the clean architecture pattern. 